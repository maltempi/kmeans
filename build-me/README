Implementação da paralelização do algoritmo K-means em CUDA e OPENMP.

Esta implementação foi feita para o projeto final da disciplina MO644 da pós graduação do instituto de computação da Universidade Estadual de Campinas (Unicamp).

Autores:
	Alex S. Torres - alexst07@gmail.com - RA. 61939
	Thiago J. M. Maltempi - tmmaltempi@gmail.com - R.A. 180070

Este código está disponível em github.com.br/maltempi/kmeans. E futuramente servirá como contribuição de duas implementações (cuda e openmp) para um repositório que possui implementações do K-means em várias linguagens de programação. (github.com/andreaferretti/kmeans)

-----

Observacao. A implementação de OpenMP possui o paralelismo da função que é o maior hotspot da aplicação: group_by_cluster. O objetivo de fazer a implementação em OpenMP foi mostrar a eficiência da programação paralela em GPU com a eficiência da programação paralela em CPU. Porém, o foco deste trabalho é a paralelização do algoritmo de K-means com a plataforma CUDA.

-----

Requisitos mínimos para compilação e execução:

 -> Cuda 7.0
 -> GCC 4.8.8

-----
Estrutura do diretório:

/ra61939-180070 --------------> root
--cuda/ ----------------------> cuda implementation
----src/ ---------------------> cuda source
------{source-files} ---------> source files...
----makefile -----------------> makefile
----build/ -------------------> created on make execution - compilation outputs
----kmeans.out ---------------> executable implementation - created on make execution
--openmp/ --------------------> openmp implementation
----src/ ---------------------> openmp implementation
------{source-files} ---------> soruce files...
----makefile -----------------> makefile
----build/ -------------------> created on make execution
----kmeans.out ---------------> executable implmentation - created on make execution;
--input/----------------------> input files
----arq1.json ----------------> file with    10,000 points
----arq2.json ----------------> file with   100,000 points
----arq3.json ----------------> file with 1,000,000 points
--output.dat -----------------> algorithm results

-----

Arquivos de entrada

Há três arquivos de entrada disponíveis na pasta $ra61939-ra180070/input chamados arq1.json, arq2.json e arq3.json, que possuem 10000, 100000 e 1000000 pontos de entrada consecutivamente.
Estes arquivos possuem a estrutura de json, sendo uma lista com N sublistas, sendo cada sublista um ponto composto por x e y, sendo x e y floats.

Exemplo da estrutura do json:
	[ [123.00, 234.00], [345.00, 456.00], ... ]

-----

Arquivos de saída

Na raiz do diretório existe um arquivo chamado output.dat, que é o arquivo de saida.
A cada execução é adicionado a este arquivo a seguinte estrutura:

{ ARQUIVO_EXECUTADO }
----------------------
{ DATA_DE_EXECUCAO }
{ ARQUIVO_EXECUTADO }

Resultado:
{ [x, y] - [numero de points associados ao grupo] }

Speedup: xx 

---------------------------------------------------

-----

Compilação:

CUDA
	$/ra61939-ra180070/cuda/ make

OpenMP
	$/ra61939-ra180070/openmp/ make

-----

Execução:

CUDA
	$/ra61939-ra180070/cuda/kmeans.out [ path-arquivo-entrada ] [ qtde_points ] [ qtde_centroids ]

OpenMP
	$/ra61939-ra180070/cuda/kmeans.out [ path-arquivo-entrada ] [ qtde_points ] [ qtde_centroids ]

-----
